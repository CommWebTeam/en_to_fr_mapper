<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>change WET file language</title>
<script src="../util/str_format_helpers.js"></script> 
<script src="../util/array_helpers.js"></script>
<script src="../util/download.js"></script> 
<script src="part1_strip_html.js"></script> 
<script src="part2_print_diff_len.js"></script> 
<script>
unmatchable_string_emptyline = "EMPTYLINEFILLER123456789"
unmatchable_string_placeholder = "FILLER123456789PLACEHOLDER"
script_notify = "SUPERSCRIPTORSUBSCRIPT"

/*
=================================
Part 1 - get content
=================================
*/

// read in uploaded file as string
function upload(element_id) {
	// store file in array
	curr_file = []
	// read file using file reader
	file_reader = new FileReader()
	file_str = document.getElementById(element_id).files[0]
	file_reader.onload = function(event) {
		// save string to array
		curr_file[0] = event.target.result
	}
	file_reader.readAsText(file_str)
	return curr_file[0]
}

// Get uploaded files and download their lists of contents
function create_content_lists() {
	// English
	// read in uploaded file as string
	file_reader_en = new FileReader()
	dirty_file_en = document.getElementById("dirty_en").files[0]
	file_reader_en.onload = function(event) {
		// clean string
		console.log("number of en values:")
		values_en = strip_html(event.target.result)
		// download file
		download(values_en, "en_values.txt", "text/plain")
	}
	file_reader_en.readAsText(dirty_file_en)
	
	// French
	file_reader_fr = new FileReader()
	dirty_fr_file = document.getElementById("dirty_fr").files[0]
	file_reader_fr.onload = function(event) {
		console.log("number of fr values:")
		values_fr = strip_html(event.target.result)
		download(values_fr, "fr_values.txt", "text/plain")
	}
	file_reader_fr.readAsText(dirty_fr_file)
}

/*
=================================
Part 2 - create french structure
=================================
*/

// Compare content lengths
function compare_content_len(a, b) {
	return a.len - b.len
}

// Replace English substrings with French substrings
function replace_en_with_fr(en_structure, en_contents, fr_contents, min_cont_len) {
	ncontents = Math.min(en_contents.length, fr_contents.length)
	unmatched_lines = 0
	unmatched_excluding_placeholder = 0
	console.log("Unmatched lines (first 100):")
	// lines of structure - one to return, one to keep track of edited lines, one without super/subscripts
	struct_lines = en_structure.split("\n")
	struct_lines_placeholder = en_structure.split("\n")
	struct_lines_no_script = en_structure.replaceAll(/<\/*su[bp]>/g, "").split("\n")
	/*
	============================
	format en contents and convert to regex
	============================
	*/
	// replace inconsistent chars
	en_contents_orig = en_contents.map(replace_special_chars)
	en_contents_orig = en_contents_orig.map(rm_extra_space)
	en_contents_orig = en_contents_orig.map(x => x.replaceAll(/^ *(&nbsp;)* *$/g, ""))
	// replace blank lines with some unmatchable string to exclude from regex
	en_contents_orig = replace_empty_lines(en_contents_orig, unmatchable_string_emptyline)
	// reformat regex chars
	en_contents_regex = en_contents_orig.map(replace_regex_chars)
	// make nbsp optional
	en_contents_regex = en_contents_regex.map(x => x.replaceAll("&nbsp;", "(?:&nbsp;)* *"))
	/*
	============================
	sort content by length
	============================
	*/
	content_len = []
	for (i = 0; i < ncontents; i++) {
		content_len.push({position: i, len: en_contents_regex[i].length})
	}
	content_len.sort(compare_content_len).reverse()
	// loop through english content and get its index in remaining structure
	for (i = 0; i < ncontents; i++) {
		posn = content_len[i].position
		curr_content = en_contents_regex[posn].trim()
		curr_content_orig = en_contents_orig[posn].trim()
		equiv_fr_content = fr_contents[posn]
		curr_content_regex = new RegExp(curr_content, "g")
		content_found = false
		/*
		============================
		actual values
		============================
		*/
		// check for fully matching tag/newline/sentence first
		newline_match = new RegExp("((^|>) *)" + curr_content + "( *($|<))", "g")
		content_ind = regex_ind(struct_lines_placeholder, newline_match, -1)
		// if match is found, change structure value and set struct counter
		if (content_ind > -1) {
			content_found = true
			struct_lines[content_ind] = struct_lines[content_ind].replace(newline_match, "$1" + equiv_fr_content + "$3")
			struct_lines_placeholder[content_ind] = struct_lines[content_ind].replace(curr_content_regex, unmatchable_string_placeholder)
		}
		if (curr_content.length >= min_cont_len) {
			// check for partial match where content is found in tag/line, but tag/line doesn't consist entirely of it
			word_match = new RegExp("(^|[^a-zA-Z0-9])" + curr_content + "($|[^a-zA-Z0-9])", "g")
			content_ind = regex_ind(struct_lines_placeholder, word_match, content_ind)
			// if match is found, change structure value and set struct counter
			if ((content_ind > -1) && (!content_found)) {
				content_found = true
				struct_lines[content_ind] = struct_lines[content_ind].replace(word_match, "$1" + equiv_fr_content + "$2")
				struct_lines_placeholder[content_ind] = struct_lines[content_ind].replace(curr_content_regex, unmatchable_string_placeholder)
			}
		}
		/*
		============================
		remove list numberings
		============================
		*/
		// only assume it's a list value if there are letters
		if (/[a-zA-Z]/g.test(curr_content)) {
			// check for match after list numbering is removed
			list_match = new RegExp("((^|>) *)([0-9Ii]*[\.-][0-9Ii]* *)*" + curr_content + "( *($|<))", "g")
			content_ind = regex_ind(struct_lines_placeholder, list_match, content_ind)
			// if match is found, change structure value and set struct counter
			if ((content_ind > -1) && (!content_found)) {
				content_found = true
				struct_lines[content_ind] = struct_lines[content_ind].replace(list_match, "$1" + equiv_fr_content + "$4")
				struct_lines_placeholder[content_ind] = struct_lines[content_ind].replace(curr_content_regex, unmatchable_string_placeholder)
			}
		}
		/*
		============================
		remove superscripts and subscripts
		============================
		*/
		// check for match after sup and sub tags are removed
		content_ind = regex_ind(struct_lines_no_script, newline_match, content_ind)
		// if match is found, change structure value and set struct counter
		if ((content_ind > -1) && (!content_found)) {
			content_found = true
			struct_lines[content_ind] = script_notify + struct_lines_no_script[content_ind].replace(newline_match, "$1" + equiv_fr_content + "$3")
			struct_lines_placeholder[content_ind] = struct_lines_no_script[content_ind].replace(curr_content_regex, unmatchable_string_placeholder)
		}
		/*
		============================
		disregard spacing
		============================
		*/
		if (curr_content.length >= min_cont_len) {
			// check for match after sup and sub tags are removed
			space_match = new RegExp("((^|>) *)" + curr_content.replaceAll(" *", " ").replaceAll(" ", " *") + "( *($|<))", "g")
			content_ind = regex_ind(struct_lines_placeholder, space_match, content_ind)
			// if match is found, change structure value and set struct counter
			if ((content_ind > -1) && (!content_found)) {
				content_found = true
				struct_lines[content_ind] = struct_lines[content_ind].replace(space_match, "$1" + equiv_fr_content + "$3")
				struct_lines_placeholder[content_ind] = struct_lines[content_ind].replace(curr_content_regex, unmatchable_string_placeholder)
			}
		}
		/*
		============================
		placeholders instead of non-alphanumeric characters
		============================
		*/
		if (curr_content.length >= min_cont_len) {
			// check for alphanumeric matches: leading/trailing non-alphanumeric characters are removed
			special_match_str = curr_content_orig.replace(/^[^0-9a-zA-Z]*(.*)/g, "$1").replace(/(.*)[^0-9a-zA-Z]*$/g, "$1")
			// internal special characters are replaced with placeholders
			special_match_str = special_match_str.replaceAll(/&[a-zA-Z0-9]+;/g, " ")
			// internal non-alphanumeric characters are replaced with placeholders
			special_match_str = special_match_str.replaceAll(/[^a-zA-Z0-9]/g, " *[^a-zA-Z0-9] *")
			special_match_str_regex = new RegExp(special_match_str)
			// check this for fully matching tag/newline first
			newline_special_match = new RegExp("((^|>) *)" + special_match_str + "( *($|<))", "g")
			content_ind = regex_ind(struct_lines_placeholder, newline_special_match, content_ind)
			// if match is found, change structure value and set struct counter
			if ((content_ind > -1) && (!content_found)) {
				content_found = true
				struct_lines[content_ind] = struct_lines[content_ind].replace(newline_special_match, "$1" + equiv_fr_content + "$3")
				struct_lines_placeholder[content_ind] = struct_lines[content_ind].replace(special_match_str_regex, unmatchable_string_placeholder)
			}
			// check for partial match
			word_special_match = new RegExp("(^|[^a-zA-Z0-9])" + special_match_str + "($|[^a-zA-Z0-9])", "g")
			content_ind = regex_ind(struct_lines_placeholder, word_special_match, content_ind)
			// if match is found, change structure value and set struct counter
			if ((content_ind > -1) && (!content_found)) {
				content_found = true
				struct_lines[content_ind] = struct_lines[content_ind].replace(word_special_match, "$1" + equiv_fr_content + "$2")
				struct_lines_placeholder[content_ind] = struct_lines[content_ind].replace(special_match_str_regex, unmatchable_string_placeholder)
			}
		}
		
		// if match is found, change structure value and set struct counter
		if (content_ind == -1) {
			if (unmatched_lines < 100) {
				console.log(posn + 1)
			}
			unmatched_lines++
			if (curr_content != unmatchable_string_emptyline) {
				unmatched_excluding_placeholder++
			}
		}
	}
	console.log("Total unmatched lines:")
	console.log(unmatched_lines)
	console.log("Unmatched lines excluding placeholders:")
	console.log(unmatched_excluding_placeholder)
	// replace link formattings and footnotes
	struct_lines = replace_arr(struct_lines, "/eng/", "/fra/")
	struct_lines = replace_arr(struct_lines, "/Eng/", "/Fra/")
	struct_lines = replace_arr(struct_lines, "Return to footnote", "Retour à la référence de la note de bas de page")
	struct_lines = replace_arr(struct_lines, "Footnotes", "Notes de bas de page")
	struct_lines = replace_arr(struct_lines, "Footnote", "Note de bas de page")
	return struct_lines.join('\n')
}

// Get lists of contents and replace English terms with French terms
function create_fr_html(dl = false) {
	// file inputs - en content and fr content in that order
	content_inputs = ["", ""]
	// read in content files as strings
	// english content
	file_reader_content_en = new FileReader()
	content_str_en = document.getElementById("content_en").files[0]
	file_reader_content_en.onload = function(event) {
		content_inputs[0] = event.target.result
	}
	file_reader_content_en.readAsText(content_str_en)
    // french content
	file_reader_content_fr = new FileReader()
	content_str_fr = document.getElementById("content_fr").files[0]
	file_reader_content_fr.onload = function(event) {
		content_inputs[1] = event.target.result
	}
	file_reader_content_fr.readAsText(content_str_fr)

	// compare english and french contents
	file_reader_en_struct = new FileReader()
	struct_str_en = document.getElementById("cleaned_en").files[0]
	file_reader_en_struct.onload = function(event) {
		// read in english and french contents
		en_contents = content_inputs[0].split("\n")
		fr_contents = content_inputs[1].split("\n")
		if (dl) {
			// read in english structure
			structure = replace_special_chars(event.target.result)
			structure = rm_extra_space(structure)
			// read in other inputs for matching contents to structure
			min_cont_len = parseInt(document.getElementById("min_content_len").value)
			// replace english content in structure with french content
			new_structure = replace_en_with_fr(structure, en_contents, fr_contents, min_cont_len)
			// download structure with french content
			download(new_structure, "fr_html.html", "text/html")
		} else {
			// check for length differences
			min_len_diff = parseInt(document.getElementById("len_diff").value)
			len_diff_skip = parseInt(document.getElementById("len_skip").value)
			print_diff_len(en_contents, fr_contents, min_len_diff, len_diff_skip)
		}
	}
	file_reader_en_struct.readAsText(struct_str_en)
}
</script>
</head>

<body>
<div><form>
  Dreamweaver-generated English HTML:
  <input id="dirty_en" type="file" />
  <br>
  <br>
  Dreamweaver-generated French HTML:
  <input id="dirty_fr" type="file" />
  <br>
  <br>
</form>
<button onclick="create_content_lists()">Download English and French values</button></div>
<br>
<br>
<br>
<form>
  Aligned English values generated above:
  <input id="content_en" type="file" />
  <br>
  <br>
  Aligned French values generated above:
  <input id="content_fr" type="file" />
  <br>
  <br>
  WET English HTML:
  <input id="cleaned_en" type="file" />
  <br>
  <br><br>
  Minimum content length difference to check for in log (multiples):
  <input id="len_diff" type="number" value="3" /> times
  <br><br>
  Number of content length differences to skip:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <input id="len_skip" type="number" value="0" />
  <br>
  <br>
  Minimum content length for partial matches (content is found in part of a tag/line, but the tag/line doesn't consist entirely of it):
  <input id="min_content_len" type="number" value="10" /> times
  <br><br>
</form>
<button onclick="create_fr_html()">Check WET French HTML</button><br><br>
<button onclick="create_fr_html(true)">Download WET French HTML</button>
<br>
<br>
<br>
<p>This application tries to fill in the wet French document after the wet English document has been manually completed. It works on the assumptions that a) the original (non-wet) documents have similar document structures and b) the wet html documents should have identical structures. With that in mind, it replaces the English values in the wet html document with their equivalent French values.</p>
<p>This can also be used in reverse if the French document was formatted by wet first.</p>
<p>Steps:</p>
<ol>
  <li>In Word, stop tracking changes.</li>
  <li>Remove filled-in values and formatting from both the English and French word documents (ctrl+6 and ctrl+shift+n - you may want to save copies of the documents before doing this).</li>
  <li>Paste these documents as HTML files into the Dreamweaver design view in separate files.</li>
  <li>Upload these two HTML files below.</li>
  <li>Download the values that are generated (these are the html documents with the tags removed).</li>
  <li>Make sure there are exactly the same number of English and French values (number of values is printed in the console) since the next part matches by index.</li>
  <li>If they don't, manually add blank rows to the shorter document in the positions where the corresponding English and French values don't align. (It's better to add lines to the English content than remove them so you don't miss any matches. Either adding or removing lines is fine for the French content.) Any editor with row numbers is fine for this.</li>
  <li>Upload the values below after you've made sure they align.</li>
  <li>Upload the English document that was formatted by WET standards.</li>
  <li>Download the French document that should now be formatted by WET standards.</li>
  <li><p><strong>Pasting word documents into Dreamweaver does NOT include superscripts and subscripts</strong> - you will have to add these in manually.</p><p>Lines that include &lt;sub&gt; or &lt;sup&gt; have been marked by SUPERSCRIPTORSUBSCRIPT. Go through the document and search for SUPERSCRIPTORSUBSCRIPT to manually add in superscripts and subscripts.</p></li>
  <li>Make sure to double check with beyond compare as usual.</li>
</ol>
<p>Possible todos:</p>
<ol>
  <li>Get rid of Dreamweaver autogenerated links.</li>
  <li>Add the option to add markers before headings for easier beyond comparing.</li>
</ol>
</body>
</html>